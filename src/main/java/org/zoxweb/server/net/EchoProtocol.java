package org.zoxweb.server.net;

import org.zoxweb.server.io.ByteBufferUtil;
import org.zoxweb.server.io.IOUtil;
import org.zoxweb.server.io.UByteArrayOutputStream;
import org.zoxweb.server.net.ssl.SSLContextInfo;
import org.zoxweb.server.net.ssl.SSLNIOSocketFactory;
import org.zoxweb.server.net.ssl.SSLSessionCallback;
import org.zoxweb.server.task.TaskUtil;
import org.zoxweb.shared.util.InstanceCreator;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

public class EchoProtocol
{
    private final static InstanceCreator<PlainSessionCallback> echoPIC = EchoSession::new;

    private final static InstanceCreator<SSLSessionCallback> echoSIC = SSLEchoSession::new;

    public static class EchoSession
        extends PlainSessionCallback
    {
        private final  UByteArrayOutputStream ubaos = new UByteArrayOutputStream();
        @Override
        public void accept(ByteBuffer byteBuffer)
        {
            try
            {
               mergedCallback(byteBuffer, ubaos, get());
            } catch (IOException e) {
                e.printStackTrace();
                IOUtil.close(get());
            }
        }
    }

    public static class SSLEchoSession
            extends SSLSessionCallback
    {

        private final UByteArrayOutputStream ubaos = new UByteArrayOutputStream();
        @Override
        public void accept(ByteBuffer byteBuffer)
        {
            try
            {
                mergedCallback(byteBuffer, ubaos, get());
            } catch (IOException e) {
                e.printStackTrace();
                IOUtil.close(get());
            }
        }
    }

    private static void mergedCallback(ByteBuffer bb, UByteArrayOutputStream ubaos, OutputStream os)
            throws IOException
    {
        ByteBufferUtil.write(bb, ubaos, true);
        if (ubaos.byteAt(ubaos.size() - 1) == (byte)'\n')
        {
            os.write(ubaos.getInternalBuffer(), 0, ubaos.size());
            ubaos.reset();
        }
    }


    public static void main(String ...args)
    {
        try
        {

            // Plain socket port not encrypted
            int port = 1024;
            // Secure socket port encrypted port
            int sPort = 1025;
            // Socket backlog
            int backlog = 128;
            // Creating the NIOSocket with and executor object
            NIOSocket nioSocket = new NIOSocket(TaskUtil.getDefaultTaskProcessor());
            // Adding the plain socket factory to process non encrypted data
            // The echoPIC is the plain socket instance creator for the EchoSession class
            nioSocket.addSeverSocket(port, backlog, new NIOPlainSocketFactory(echoPIC));

            try
            {

                // Adding the self-signed autogenerated keystore
                SSLContextInfo sslContextInfo = org.zoxweb.server.security.CertKStoreUtil.generateRandomSSLContextInfo("ec", "SHA256withECDSA");
                // The echoSIC is the secure socket instance creator for the SSLEchoSession class
                SSLNIOSocketFactory sslnioSocketFactory = new SSLNIOSocketFactory(sslContextInfo, echoSIC);
                //Registering the socket and port
                nioSocket.addSeverSocket(sPort, backlog, sslnioSocketFactory);
            }
            catch(Exception e)
            {
                e.printStackTrace();
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            System.exit(-1);
        }
    }

}
