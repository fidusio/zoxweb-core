package org.zoxweb.server.net.protocols;

import org.zoxweb.server.io.ByteBufferUtil;
import org.zoxweb.server.io.IOUtil;
import org.zoxweb.server.io.UByteArrayOutputStream;
import org.zoxweb.server.net.BaseChannelOutputStream;
import org.zoxweb.server.net.BaseSessionCallback;
import org.zoxweb.server.net.ssl.SSLSessionConfig;
import org.zoxweb.shared.util.InstanceFactory;

import java.io.IOException;
import java.nio.ByteBuffer;

public class EchoProtocol {
    private final static InstanceFactory.Creator<BaseSessionCallback<BaseChannelOutputStream>> echoPIC = EchoSession::new;

    private final static InstanceFactory.Creator<BaseSessionCallback<SSLSessionConfig>> echoSIC = SSLEchoSession::new;

    public static class EchoSession
            extends BaseSessionCallback<BaseChannelOutputStream> {
        private final UByteArrayOutputStream ubaos = new UByteArrayOutputStream();

        @Override
        public void accept(ByteBuffer byteBuffer) {
            try {
                ByteBufferUtil.write(byteBuffer, ubaos, true);
                if (ubaos.byteAt(ubaos.size() - 1) == (byte) '\n') {
                    getOutputStream().write(ubaos, true);
                }
            } catch (IOException e) {
                e.printStackTrace();
                IOUtil.close(getOutputStream());
            }
        }

        /**
         * Closes this stream and releases any system resources associated
         * with it. If the stream is already closed then invoking this
         * method has no effect.
         *
         * <p> As noted in {@link AutoCloseable#close()}, cases where the
         * close may fail require careful attention. It is strongly advised
         * to relinquish the underlying resources and to internally
         * <em>mark</em> the {@code Closeable} as closed, prior to throwing
         * the {@code IOException}.
         *
         * @throws IOException if an I/O error occurs
         */
        @Override
        public void close() throws IOException {

        }

        @Override
        public boolean isClosed() {
            return getOutputStream() != null && getOutputStream().isClosed();
        }

        @Override
        public void exception(Throwable e) {

        }
    }

    public static class SSLEchoSession
            extends BaseSessionCallback<SSLSessionConfig> {

        private final UByteArrayOutputStream ubaos = new UByteArrayOutputStream();

        @Override
        public void accept(ByteBuffer byteBuffer) {
            try {
                ByteBufferUtil.write(byteBuffer, ubaos, true);
                if (ubaos.byteAt(ubaos.size() - 1) == (byte) '\n') {
                    getOutputStream().write(ubaos, true);
                }
            } catch (IOException e) {
                e.printStackTrace();
                IOUtil.close(getOutputStream());
            }
        }

        /**
         * Closes this stream and releases any system resources associated
         * with it. If the stream is already closed then invoking this
         * method has no effect.
         *
         * <p> As noted in {@link AutoCloseable#close()}, cases where the
         * close may fail require careful attention. It is strongly advised
         * to relinquish the underlying resources and to internally
         * <em>mark</em> the {@code Closeable} as closed, prior to throwing
         * the {@code IOException}.
         *
         * @throws IOException if an I/O error occurs
         */
        @Override
        public void close() throws IOException {

        }

        /**
         * @return
         */
        @Override
        public boolean isClosed() {
            return getOutputStream() != null && getOutputStream().isClosed();
        }

        @Override
        public void exception(Throwable e) {

        }
    }

//    public static void main(String ...args)
//    {
//        try
//        {
//
//            // Plain socket port not encrypted
//            int port = 1025;
//            // Secure socket port encrypted port
//            int sPort = 1026;
//            // Socket backlog
//            int backlog = 128;
//            // Creating the NIOSocket with and executor object
//            NIOSocket nioSocket = new NIOSocket(TaskUtil.defaultTaskProcessor(), TaskUtil.defaultTaskScheduler());
//            // Adding the plain socket factory to process non encrypted data
//            // The echoPIC is the plain socket instance creator for the EchoSession class
//            nioSocket.addServerSocket(port, backlog, new NIOSocketHandlerFactory(echoPIC));
//
//
//
//            // this section will create secure socket handler
//            try
//            {
//
//                // Adding the self-signed autogenerated keystore FOR TESTING PURPOSES ONLY
//                // NEVER USE IT in production
//                SSLContextInfo sslContextInfo = org.zoxweb.server.security.CertKStoreUtil.generateRandomSSLContextInfo("ec", "SHA256withECDSA");
//                // The echoSIC is the secure socket instance creator for the SSLEchoSession class
//                SSLNIOSocketHandlerFactory sslnioSocketFactory = new SSLNIOSocketHandlerFactory(sslContextInfo, echoSIC);
//                //Registering the socket and port
//                nioSocket.addServerSocket(sPort, backlog, sslnioSocketFactory);
//            }
//            catch(Exception e)
//            {
//                e.printStackTrace();
//            }
//        }
//        catch (Exception e)
//        {
//            e.printStackTrace();
//            System.exit(-1);
//        }
//    }

}
